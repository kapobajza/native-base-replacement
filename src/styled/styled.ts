import _ from 'lodash';
import type { ComponentType, FC } from 'react';
import { createElement } from 'react';
import { useMemo } from 'react';
import { forwardRef } from 'react';
import { useTheme } from '../theme/ThemeProvider';

import { allStyledConfig } from './props';
import type { ComponentStyledProps } from './types';

export default function styled<TProps>(
  Component: ComponentType<TProps>,
): FC<ComponentStyledProps & TProps & { ref?: unknown }> {
  type FinalComponentProps = TProps & ComponentStyledProps;

  return forwardRef<
    React.ComponentType<FinalComponentProps>,
    FinalComponentProps
  >(
    (
      {
        margin,
        m,
        marginTop,
        mt,
        marginRight,
        mr,
        marginBottom,
        mb,
        marginLeft,
        ml,
        marginX,
        mx,
        marginY,
        my,
        padding,
        p,
        paddingTop,
        pt,
        paddingRight,
        pr,
        paddingBottom,
        pb,
        paddingLeft,
        pl,
        paddingX,
        px,
        paddingY,
        py,
        gap,
        width,
        w,
        height,
        h,
        minWidth,
        minW,
        minHeight,
        minH,
        maxWidth,
        maxW,
        maxHeight,
        maxH,
        size,
        boxSize,
        display,
        overflowX,
        overflowY,
        textAlign,
        verticalAlign,
        overflow,
        backgroundColor,
        color,
        textDecorationColor,
        background,
        tintColor,
        bg,
        bgColor,
        opacity,
        fontStyle,
        lineHeight,
        overflowWrap,
        textDecorationLine,
        textOverflow,
        textTransform,
        whiteSpace,
        wordBreak,
        fontWeight,
        fontFamily,
        fontSize,
        letterSpacing,
        alignContent,
        alignItems,
        alignSelf,
        flexBasis,
        flexDirection,
        flexGrow,
        flexShrink,
        flexWrap,
        justifyContent,
        justifyItems,
        justifySelf,
        order,
        flex,
        bottom,
        left,
        right,
        top,
        position,
        borderBottomStyle,
        borderLeftStyle,
        borderRightStyle,
        borderTopStyle,
        borderBottom,
        borderLeft,
        borderRight,
        borderStyle,
        borderTop,
        borderBottomColor,
        borderLeftColor,
        borderRightColor,
        borderTopColor,
        borderColor,
        borderBottomLeftRadius,
        borderBottomRightRadius,
        borderTopLeftRadius,
        borderTopRightRadius,
        borderRadius,
        borderTopRadius,
        borderLeftRadius,
        borderRightRadius,
        borderBottomWidth,
        borderLeftWidth,
        borderRightWidth,
        borderTopWidth,
        borderWidth,
        backgroundAttachment,
        backgroundBlendMode,
        backgroundRepeat,
        backgroundSize,
        backgroundPosition,
        zIndex,
        shadowOpacity,
        shadowRadius,
        shadowColor,
        shadowOffset,
        elevation,
        shadow,
        style: propsStyle,
        ...props
      },
      ref,
    ) => {
      const styleProps = useMemo<ComponentStyledProps>(() => {
        const finalProps: ComponentStyledProps = {};

        const allProps: ComponentStyledProps = {
          margin,
          m,
          marginTop,
          mt,
          marginRight,
          mr,
          marginBottom,
          mb,
          marginLeft,
          ml,
          marginX,
          mx,
          marginY,
          my,
          padding,
          p,
          paddingTop,
          pt,
          paddingRight,
          pr,
          paddingBottom,
          pb,
          paddingLeft,
          pl,
          paddingX,
          px,
          paddingY,
          py,
          gap,
          width,
          w,
          height,
          h,
          minWidth,
          minW,
          minHeight,
          minH,
          maxWidth,
          maxW,
          maxHeight,
          maxH,
          size,
          boxSize,
          display,
          overflowX,
          overflowY,
          textAlign,
          verticalAlign,
          overflow,
          backgroundColor,
          color,
          textDecorationColor,
          background,
          tintColor,
          bg,
          bgColor,
          opacity,
          fontStyle,
          lineHeight,
          overflowWrap,
          textDecorationLine,
          textOverflow,
          textTransform,
          whiteSpace,
          wordBreak,
          fontWeight,
          fontFamily,
          fontSize,
          letterSpacing,
          alignContent,
          alignItems,
          alignSelf,
          flexBasis,
          flexDirection,
          flexGrow,
          flexShrink,
          flexWrap,
          justifyContent,
          justifyItems,
          justifySelf,
          order,
          flex,
          bottom,
          left,
          right,
          top,
          position,
          borderBottomStyle,
          borderLeftStyle,
          borderRightStyle,
          borderTopStyle,
          borderBottom,
          borderLeft,
          borderRight,
          borderStyle,
          borderTop,
          borderBottomColor,
          borderLeftColor,
          borderRightColor,
          borderTopColor,
          borderColor,
          borderBottomLeftRadius,
          borderBottomRightRadius,
          borderTopLeftRadius,
          borderTopRightRadius,
          borderRadius,
          borderTopRadius,
          borderLeftRadius,
          borderRightRadius,
          borderBottomWidth,
          borderLeftWidth,
          borderRightWidth,
          borderTopWidth,
          borderWidth,
          backgroundAttachment,
          backgroundBlendMode,
          backgroundRepeat,
          backgroundSize,
          backgroundPosition,
          zIndex,
          shadowOpacity,
          shadowRadius,
          shadowColor,
          shadowOffset,
          elevation,
          shadow,
        };

        Object.keys(allProps).forEach(key => {
          const propKey = key as keyof Omit<ComponentStyledProps, 'style'>;
          const value = allProps[propKey];

          if (!_.isUndefined(value) && !_.isNull(value)) {
            // @ts-expect-error Too complex union type
            finalProps[propKey] = value;
          }
        });

        return finalProps;
      }, [
        alignContent,
        alignItems,
        alignSelf,
        background,
        backgroundAttachment,
        backgroundBlendMode,
        backgroundColor,
        backgroundPosition,
        backgroundRepeat,
        backgroundSize,
        bg,
        bgColor,
        borderBottom,
        borderBottomColor,
        borderBottomLeftRadius,
        borderBottomRightRadius,
        borderBottomStyle,
        borderBottomWidth,
        borderColor,
        borderLeft,
        borderLeftColor,
        borderLeftRadius,
        borderLeftStyle,
        borderLeftWidth,
        borderRadius,
        borderRight,
        borderRightColor,
        borderRightRadius,
        borderRightStyle,
        borderRightWidth,
        borderStyle,
        borderTop,
        borderTopColor,
        borderTopLeftRadius,
        borderTopRadius,
        borderTopRightRadius,
        borderTopStyle,
        borderTopWidth,
        borderWidth,
        bottom,
        boxSize,
        color,
        display,
        elevation,
        flex,
        flexBasis,
        flexDirection,
        flexGrow,
        flexShrink,
        flexWrap,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        gap,
        h,
        height,
        justifyContent,
        justifyItems,
        justifySelf,
        left,
        letterSpacing,
        lineHeight,
        m,
        margin,
        marginBottom,
        marginLeft,
        marginRight,
        marginTop,
        marginX,
        marginY,
        maxH,
        maxHeight,
        maxW,
        maxWidth,
        mb,
        minH,
        minHeight,
        minW,
        minWidth,
        ml,
        mr,
        mt,
        mx,
        my,
        opacity,
        order,
        overflow,
        overflowWrap,
        overflowX,
        overflowY,
        p,
        padding,
        paddingBottom,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingX,
        paddingY,
        pb,
        pl,
        position,
        pr,
        pt,
        px,
        py,
        right,
        shadow,
        shadowColor,
        shadowOffset,
        shadowOpacity,
        shadowRadius,
        size,
        textAlign,
        textDecorationColor,
        textDecorationLine,
        textOverflow,
        textTransform,
        tintColor,
        top,
        verticalAlign,
        w,
        whiteSpace,
        width,
        wordBreak,
        zIndex,
      ]);

      const theme = useTheme();

      const style = useMemo(() => {
        const finalStyle: Record<string, unknown> = {};

        Object.keys(styleProps).forEach(key => {
          const stylePropKey = key as keyof typeof allStyledConfig;
          const value = styleProps[stylePropKey];
          const styledConfig = allStyledConfig[stylePropKey];

          if (!_.isUndefined(value)) {
            if (typeof styledConfig === 'boolean') {
              finalStyle[stylePropKey] = value;
            } else {
              const { properties, scale, transform } = styledConfig;

              properties.forEach(property => {
                let finalValue: string | number | undefined;

                const themeObject: Record<string, unknown> = scale
                  ? theme[scale]
                  : {};

                if (transform) {
                  finalValue = transform(
                    themeObject as Record<string, string | number>,
                    value as string,
                    theme,
                    property,
                  );
                } else {
                  finalValue = _.get(themeObject, value, value) as string;
                }

                finalStyle[property] = finalValue;
              });
            }
          }
        });

        return finalStyle;
      }, [styleProps, theme]);

      return createElement(Component as never, {
        ...props,
        style: [style, propsStyle],
        ref,
      });
    },
  ) as FC<FinalComponentProps & { ref?: unknown }>;
}
